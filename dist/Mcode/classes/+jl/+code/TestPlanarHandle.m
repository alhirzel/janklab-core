classdef TestPlanarHandle < jl.code.TestAbstractHandle
    
    % @planarprecedence(foo, bar, baz, qux)
    
    properties
        foo % @planar
        bar % @planar
        baz % @planar
        qux % @planar
    end
    
    %%%%% START PLANAR-CLASS BOILERPLATE CODE %%%%%
    
    % This section contains code auto-generated by Janklab's genPlanarClass.
    % Do not edit code in this section manually.
    % Do not remove the "%%%%% START/END .... %%%%%" header or footer either;
    % that will cause the code regeneration to break.
    % To update this code, re-run jl.code.genPlanarClass() on this file.
    
    methods
    
        function out = size(this)
        %SIZE Size of array.
        out = size(this.foo);
        end
        
        function out = numel(this)
        %NUMEL Number of elements in array.
        out = numel(this.foo);
        end
        
        function out = ndims(this)
        %NDIMS Number of dimensions.
        out = ndims(this.foo);
        end
        
        function out = isempty(this)
        %ISEMPTY True for empty array.
        out = isempty(this.foo);
        end
        
        function out = isscalar(this)
        %ISSCALAR True if input is scalar.
        out = isscalar(this.foo);
        end
        
        function out = isvector(this)
        %ISVECTOR True if input is a vector.
        out = isvector(this.foo);
        end
        
        function out = iscolumn(this)
        %ISCOLUMN True if input is a column vector.
        out = iscolumn(this.foo);
        end
        
        function out = isrow(this)
        %ISROW True if input is a row vector.
        out = isrow(this.foo);
        end
        
        function out = ismatrix(this)
        %ISMATRIX True if input is a matrix.
        out = ismatrix(this.foo);
        end
        
        function this = reshape(this)
        %RESHAPE Reshape array.
        this.foo = reshape(this.foo);
        this.bar = reshape(this.bar);
        this.baz = reshape(this.baz);
        this.qux = reshape(this.qux);
        end
        
        function this = squeeze(this)
        %SQUEEZE Remove singleton dimensions.
        this.foo = squeeze(this.foo);
        this.bar = squeeze(this.bar);
        this.baz = squeeze(this.baz);
        this.qux = squeeze(this.qux);
        end
        
        function this = circshift(this)
        %CIRCSHIFT Shift positions of elements circularly.
        this.foo = circshift(this.foo);
        this.bar = circshift(this.bar);
        this.baz = circshift(this.baz);
        this.qux = circshift(this.qux);
        end
        
        function this = permute(this)
        %PERMUTE Permute array dimensions.
        this.foo = permute(this.foo);
        this.bar = permute(this.bar);
        this.baz = permute(this.baz);
        this.qux = permute(this.qux);
        end
        
        function this = ipermute(this)
        %IPERMUTE Inverse permute array dimensions.
        this.foo = ipermute(this.foo);
        this.bar = ipermute(this.bar);
        this.baz = ipermute(this.baz);
        this.qux = ipermute(this.qux);
        end
        
        function this = repmat(this)
        %REPMAT Replicate and tile array.
        this.foo = repmat(this.foo);
        this.bar = repmat(this.bar);
        this.baz = repmat(this.baz);
        this.qux = repmat(this.qux);
        end
        
        function this = ctranspose(this)
        %CTRANSPOSE Complex conjugate transpose.
        this.foo = ctranspose(this.foo);
        this.bar = ctranspose(this.bar);
        this.baz = ctranspose(this.baz);
        this.qux = ctranspose(this.qux);
        end
        
        function this = transpose(this)
        %TRANSPOSE Transpose vector or matrix.
        this.foo = transpose(this.foo);
        this.bar = transpose(this.bar);
        this.baz = transpose(this.baz);
        this.qux = transpose(this.qux);
        end
        
        function [this, nshifts] = shiftdim(this, n)
        %SHIFTDIM Shift dimensions.
        if nargin > 1
            this.foo = shiftdim(this.foo, n);
            this.bar = shiftdim(this.bar, n);
            this.baz = shiftdim(this.baz, n);
            this.qux = shiftdim(this.qux, n);
        else
            this.foo = shiftdim(this.foo);
            this.bar = shiftdim(this.bar);
            this.baz = shiftdim(this.baz);
            [this.qux,nshifts] = shiftdim(this.qux);
        end
        end
        
        function out = cat(dim, varargin)
        %CAT Concatenate arrays.
        args = varargin;
        for i = 1:numel(args)
            if ~isa(args{i}, 'jl.code.TestPlanarHandle')
                args{i} = jl.code.TestPlanarHandle(args{i});
            end
        end
        out = args{1};
        fieldArgs = cellfun(@(obj) obj.foo, args, 'UniformOutput', false);
        out.foo = cat(dim, fieldArgs{:});
        fieldArgs = cellfun(@(obj) obj.bar, args, 'UniformOutput', false);
        out.bar = cat(dim, fieldArgs{:});
        fieldArgs = cellfun(@(obj) obj.baz, args, 'UniformOutput', false);
        out.baz = cat(dim, fieldArgs{:});
        fieldArgs = cellfun(@(obj) obj.qux, args, 'UniformOutput', false);
        out.qux = cat(dim, fieldArgs{:});
        end
        
        function out = horzcat(varargin)
        %HORZCAT Horizontal concatenation.
        out = cat(2, varargin{:});
        end
        
        function out = vertcat(varargin)
        %VERTCAT Vertical concatenation.
        out = cat(1, varargin{:});
        end
        
        function this = subsasgn(this, s, b)
        %SUBSASGN Subscripted assignment.
        
        % Chained subscripts
        if numel(s) > 1
            rhs_in = subsref(this, s(1));
            rhs = subsasgn(rhs_in, s(2:end), b);
        else
            rhs = b;
        end
        
        % Base case
        switch s(1).type
            case '()'
                this = subsasgnParensPlanar(this, s(1), rhs);
            case '{}'
                error('jl:BadOperation',...
                    '{}-subscripting is not supported for class %s', class(this));
            case '.'
                this.(s(1).subs) = rhs;
        end
        end
        
        function out = subsref(this, s)
        %SUBSREF Subscripted reference.
        
        % Base case
        switch s(1).type
            case '()'
                out = subsrefParensPlanar(this, s(1));
            case '{}'
                error('jl:BadOperation',...
                    '{}-subscripting is not supported for class %s', class(this));
            case '.'
                out = this.(s(1).subs);
        end
        
        % Chained reference
        if numel(s) > 1
            out = subsref(out, s(2:end));
        end
        end
        
        function out = eq(a, b)
        %EQ == Equal.
        if ~isa(a, 'jl.code.TestPlanarHandle')
            a = jl.code.TestPlanarHandle(a);
        end
        if ~isa(b, 'jl.code.TestPlanarHandle')
            b = jl.code.TestPlanarHandle(b);
        end
        tf = a.foo == b.foo;
        tf(tf) = a.bar(tf) == b.bar(tf);
        tf(tf) = a.baz(tf) == b.baz(tf);
        tf(tf) = a.qux(tf) == b.qux(tf);
        out = tf;
        end
        
        function out = lt(a, b)
        %LT < Less than.
        if ~isa(a, 'jl.code.TestPlanarHandle')
            a = jl.code.TestPlanarHandle(a);
        end
        if ~isa(b, 'jl.code.TestPlanarHandle')
            b = jl.code.TestPlanarHandle(b);
        end
        out = false(size(a));
        tfUndecided = true(size(out));
        % Check field foo
        lhs = a.foo(tfUndecided);
        rhs = b.foo(tfUndecided);
        tfThisStep = lhs < rhs;
        out(tfUndecided) = tfThisStep;
        tfUndecided(tfUndecided) = ~tfThisStep & ~isnan(lhs) & ~isnan(rhs);
        % Check field bar
        lhs = a.bar(tfUndecided);
        rhs = b.bar(tfUndecided);
        tfThisStep = lhs < rhs;
        out(tfUndecided) = tfThisStep;
        tfUndecided(tfUndecided) = ~tfThisStep & ~isnan(lhs) & ~isnan(rhs);
        % Check field baz
        lhs = a.baz(tfUndecided);
        rhs = b.baz(tfUndecided);
        tfThisStep = lhs < rhs;
        out(tfUndecided) = tfThisStep;
        tfUndecided(tfUndecided) = ~tfThisStep & ~isnan(lhs) & ~isnan(rhs);
        % Check field qux
        lhs = a.qux(tfUndecided);
        rhs = b.qux(tfUndecided);
        tfThisStep = lhs < rhs;
        out(tfUndecided) = tfThisStep;
        end
        
        function out = gt(a, b)
        %GT > Greater than.
        if ~isa(a, 'jl.code.TestPlanarHandle')
            a = jl.code.TestPlanarHandle(a);
        end
        if ~isa(b, 'jl.code.TestPlanarHandle')
            b = jl.code.TestPlanarHandle(b);
        end
        out = false(size(a));
        tfUndecided = true(size(out));
        % Check field foo
        lhs = a.foo(tfUndecided);
        rhs = b.foo(tfUndecided);
        tfThisStep = lhs > rhs;
        out(tfUndecided) = tfThisStep;
        tfUndecided(tfUndecided) = ~tfThisStep & ~isnan(lhs) & ~isnan(rhs);
        % Check field bar
        lhs = a.bar(tfUndecided);
        rhs = b.bar(tfUndecided);
        tfThisStep = lhs > rhs;
        out(tfUndecided) = tfThisStep;
        tfUndecided(tfUndecided) = ~tfThisStep & ~isnan(lhs) & ~isnan(rhs);
        % Check field baz
        lhs = a.baz(tfUndecided);
        rhs = b.baz(tfUndecided);
        tfThisStep = lhs > rhs;
        out(tfUndecided) = tfThisStep;
        tfUndecided(tfUndecided) = ~tfThisStep & ~isnan(lhs) & ~isnan(rhs);
        % Check field qux
        lhs = a.qux(tfUndecided);
        rhs = b.qux(tfUndecided);
        tfThisStep = lhs > rhs;
        out(tfUndecided) = tfThisStep;
        end
        
        function out = ne(a, b)
        %NE ~= Not equal.
        out = ~(a == b);
        end
        
        function out = le(a, b)
        %LE <= Less than or equal.
        out = a < b | a == b;
        end
        
        function out = ge(a, b)
        %GE <= Greater than or equal.
        out = a > b | a == b;
        end
        
        function out = cmp(a, b)
        %CMP Compare values for ordering.
        %
        % CMP compares values elementwise, returning for each element:
        %   -1 if a(i) < b(i)
        %   0  if a(i) == b(i)
        %   1  if a(i) > b(i)
        %   NaN if either a(i) or b(i) were NaN, or no relop methods returned
        %       true
        %
        % Returns an array the same size as a and b (after scalar expansion).
        
        if ~isa(a, 'jl.code.TestPlanarHandle')
            a = jl.code.TestPlanarHandle(a);
        end
        if ~isa(b, 'jl.code.TestPlanarHandle')
            b = jl.code.TestPlanarHandle(b);
        end
        out = NaN(size(a));
        tfUndecided = true(size(out));
        % Test <
        tf = a < b;
        out(tf) = -1;
        tfUndecided(tf) = false;
        % Test ==
        tf = a(tfUndecided) == b(tfUndecided);
        nextTest = NaN(size(tf));
        nextTest(tf) = 0;
        out(tfUndecided) = nextTest;
        tfUndecided(tfUndecided) = ~tf;
        % Test >
        tf = a(tfUndecided) > b(tfUndecided);
        nextTest = NaN(size(tf));
        nextTest(tf) = 1;
        out(tfUndecided) = nextTest;
        tfUndecided(tfUndecided) = ~tf; %#ok<NASGU>
        % Anything left over is either NaN inputs or an unsupported relop
        end
    
    end
    
    methods (Access=private)
    
        function this = subsasgnParensPlanar(this, s, rhs)
        %SUBSASGNPARENSPLANAR ()-assignment for planar object
        if ~isa(rhs, 'jl.code.TestPlanarHandle')
            rhs = jl.code.TestPlanarHandle(rhs);
        end
        
        this.foo(s.subs{:}) = rhs.foo;
        this.bar(s.subs{:}) = rhs.bar;
        this.baz(s.subs{:}) = rhs.baz;
        this.qux(s.subs{:}) = rhs.qux;
        end
        
        function out = subsrefParensPlanar(this, s)
        %SUBSREFPARENSPLANAR ()-indexing for planar object
        out = this;
        out.foo = this.foo(s.subs{:});
        out.bar = this.bar(s.subs{:});
        out.baz = this.baz(s.subs{:});
        out.qux = this.qux(s.subs{:});
        end
    
    end
    
    %%%%% END PLANAR-CLASS BOILERPLATE CODE %%%%%

end