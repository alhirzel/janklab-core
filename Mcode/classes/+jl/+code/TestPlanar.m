classdef TestPlanar
    
    properties
        x % @planar
        y % @planar
        notPlanar
    end
    
    properties (Constant)
        foo = 42;
    end
    
    properties
        z % @planar
    end
        
    %%%%% START PLANAR-CLASS BOILERPLATE CODE %%%%%
    
    % This section contains code auto-generated by Janklab's genPlanarClass.
    % Do not edit code in this section manually.
    % To update it, re-run jl.code.genPlanarClass() on this file.
    
    methods
    
        function out = size(this)
        %SIZE Size of array.
        out = size(this.x);
        end
        
        function out = numel(this)
        %NUMEL Number of elements in array.
        out = numel(this.x);
        end
        
        function out = ndims(this)
        %NDIMS Number of dimensions.
        out = ndims(this.x);
        end
        
        function out = isempty(this)
        %ISEMPTY True for empty array.
        out = isempty(this.x);
        end
        
        function out = isscalar(this)
        %ISSCALAR True if input is scalar.
        out = isscalar(this.x);
        end
        
        function out = isvector(this)
        %ISVECTOR True if input is a vector.
        out = isvector(this.x);
        end
        
        function out = iscolumn(this)
        %ISCOLUMN True if input is a column vector.
        out = iscolumn(this.x);
        end
        
        function out = isrow(this)
        %ISROW True if input is a row vector.
        out = isrow(this.x);
        end
        
        function out = ismatrix(this)
        %ISMATRIX True if input is a matrix.
        out = ismatrix(this.x);
        end
        
        function this = reshape(this)
        %RESHAPE Reshape array.
        out = this;
        out.x = reshape(this.x);
        out.y = reshape(this.y);
        out.z = reshape(this.z);
        end
        
        function this = squeeze(this)
        %SQUEEZE Remove singleton dimensions.
        out = this;
        out.x = squeeze(this.x);
        out.y = squeeze(this.y);
        out.z = squeeze(this.z);
        end
        
        function this = circshift(this)
        %CIRCSHIFT Shift positions of elements circularly.
        out = this;
        out.x = circshift(this.x);
        out.y = circshift(this.y);
        out.z = circshift(this.z);
        end
        
        function this = permute(this)
        %PERMUTE Permute array dimensions.
        out = this;
        out.x = permute(this.x);
        out.y = permute(this.y);
        out.z = permute(this.z);
        end
        
        function this = ipermute(this)
        %IPERMUTE Inverse permute array dimensions.
        out = this;
        out.x = ipermute(this.x);
        out.y = ipermute(this.y);
        out.z = ipermute(this.z);
        end
        
        function this = repmat(this)
        %REPMAT Replicate and tile array.
        out = this;
        out.x = repmat(this.x);
        out.y = repmat(this.y);
        out.z = repmat(this.z);
        end
        
        function this = ctranspose(this)
        %CTRANSPOSE Complex conjugate transpose.
        out = this;
        out.x = ctranspose(this.x);
        out.y = ctranspose(this.y);
        out.z = ctranspose(this.z);
        end
        
        function this = transpose(this)
        %TRANSPOSE Transpose vector or matrix.
        out = this;
        out.x = transpose(this.x);
        out.y = transpose(this.y);
        out.z = transpose(this.z);
        end
        
        function [this, nshifts] = shiftdim(this, n)
        %SHIFTDIM Shift dimensions.
        if nargin > 1
            this.x = shiftdim(this.x, n);
            this.y = shiftdim(this.y, n);
            this.z = shiftdim(this.z, n);
        else
            this.x = shiftdim(this.x);
            this.y = shiftdim(this.y);
            [this.z,nshifts] = shiftdim(this.z);
        end
        end
        
        function out = cat(dim, this, b)
        %CAT Concatenate arrays.
        if ~isa(this, 'jl.code.TestPlanar')
            this = jl.code.TestPlanar(this);
        end
        if ~isa(b, 'jl.code.TestPlanar')
            b = jl.code.TestPlanar(b);
        end
        out = this;
        out.x = cat(dim, this.x, b.x);
        out.y = cat(dim, this.y, b.y);
        out.z = cat(dim, this.z, b.z);
        end
        
        function out = horzcat(this, b)
        %HORZCAT Horizontal concatenation.
        out = cat(2, this, b);
        end
        
        function out = vertcat(this, b)
        %VERTCAT Vertical concatenation.
        out = cat(1, this, b);
        end
        
        function this = subsasgn(this, s, b)
        %SUBSASGN Subscripted assignment.
        
        % Chained subscripts
        if numel(s) > 1
            rhs_in = subsref(this, s(1));
            rhs = subsasgn(rhs_in, s(2:end), b);
        else
            rhs = b;
        end
        
        % Base case
        switch s(1).type
            case '()'
                this = subsasgnParensPlanar(this, s(1), rhs);
            case '{}'
                error('jl:BadOperation',...
                    '{}-subscripting is not supported for class %s', class(this));
            case '.'
                this.(s(1).subs) = rhs;
        end
        end
        
        function out = subsref(this, s)
        %SUBSREF Subscripted reference.
        
        % Base case
        switch s(1).type
            case '()'
                out = subsrefParensPlanar(this, s(1));
            case '{}'
                error('jl:BadOperation',...
                    '{}-subscripting is not supported for class %s', class(this));
            case '.'
                out = this.(s(1).subs);
        end
        
        % Chained reference
        if numel(s) > 1
            out = subsref(out, s(2:end));
        end
        end
    
    end
    
    methods (Access=private)
    
        function this = subsasgnParensPlanar(this, s, rhs)
        %SUBSASGNPARENSPLANAR ()-assignment for planar object
        if ~isa(rhs, 'jl.code.TestPlanar')
            rhs = jl.code.TestPlanar(rhs);
        end
        
        this.x(s.subs{:}) = rhs.x;
        this.y(s.subs{:}) = rhs.y;
        this.z(s.subs{:}) = rhs.z;
        end
        
        function out = subsrefParensPlanar(this, s)
        %SUBSREFPARENSPLANAR ()-indexing for planar object
        out = this;
        out.x = this.x(s.subs{:});
        out.y = this.y(s.subs{:});
        out.z = this.z(s.subs{:});
        end
    
    end
    
    %%%%% END PLANAR-CLASS BOILERPLATE CODE %%%%%
    
    
end