classdef PlanarClassGenerator
    %PLANARCLASSGENERATOR Generates boilerplate code for a planar-organized class
    
    properties
        boilerplateHeader = '%%%%% START PLANAR-CLASS BOILERPLATE CODE %%%%%';
        boilerplateFooter = '%%%%% END PLANAR-CLASS BOILERPLATE CODE %%%%%';
        boilerplateLocalFcnHeader = '%%%%% START PLANAR-CLASS BOILERPLATE LOCAL FUNCTIONS %%%%%';
        boilerplateLocalFcnFooter = '%%%%% END PLANAR-CLASS BOILERPLATE LOCAL FUNCTIONS %%%%%';
        boilerplateMessage = strjoin({
            '% This section contains code auto-generated by Janklab''s genPlanarClass.'
            '% Do not edit code in this section manually.'
            '% Do not remove the "%%%%% START/END .... %%%%%" header or footer either;'
            '% that will cause the code regeneration to break.'
            '% To update this code, re-run jl.code.genPlanarClass() on this file.'
            }, '\n');
        objName = 'this';
        isHandle = false;
        % { name, H1text; ... }
        simpleQueryDelegates = {
            'numel'         'Number of elements in array.'
            'ndims'         'Number of dimensions.'
            'size'          'Size of array.'
            'isempty'       'True for empty array.'
            'isscalar'      'True if input is scalar.'
            'isvector'      'True if input is a vector.'
            'iscolumn'      'True if input is a column vector.'
            'isrow'         'True if input is a row vector.'
            'ismatrix'      'True if input is a matrix.'
            };
        % { name, H1text; ... }
        transformDelegates = {
            'reshape'       'Reshape array.'
            'squeeze'       'Remove singleton dimensions.'
            'circshift'     'Shift positions of elements circularly.'
            'permute'       'Permute array dimensions.'
            'ipermute'      'Inverse permute array dimensions.'
            'repmat'        'Replicate and tile array.'
            'ctranspose'    'Complex conjugate transpose.'
            'transpose'     'Transpose vector or matrix.'
            };
        specialDelegates = {
            'shiftdim'
            'cat'
            'horzcat'
            'vertcat'
            };
        special = {'subsasgn' 'subsref'};
    end
    
    methods

        function out = inspectFile(this, file)
        %INSPECTFILE Inspect a class file and determine planar definition
        fqClassName = this.determineClassName(file);
        originalCode = jl.io.slurp(file);
        codeInfo = this.scanCode(originalCode);
        defn = jl.code.internal.PlanarClassDefinition;
        defn = this.parseAnnotations(codeInfo.userCode, defn);
        defn = this.detectClassProperties(fqClassName, codeInfo.userCode, defn);
        defn.codeInfo = codeInfo;
        % Finish inspection
        defn.isNanable = defn.hasPlanarNanFlag || ~isempty(defn.planarNanFields) ...
            || defn.hasUserIsNan;
        out = defn;
        end
        
        function out = determineClassName(this, file) %#ok<INUSL>
        f = strrep(file, '\', '/');
        pkgPathComponent = regexp(f, '\+.*?(?=/[^+])', 'match', 'once');
        pkg = strrep(strrep(pkgPathComponent, '/', '.'), '+', '');
        [~,className] = fileparts(file);
        if isempty(pkg)
            fqClassName = className;
        else
            fqClassName = [pkg '.' className];
        end
        out = fqClassName;
        end
        
        function out = parseAnnotations(this, code, notes) %#ok<INUSL>
        %PARSEANNOTATIONS
        out = notes;
        % Find global annotations
            function [isPresent,options,nPresent] = findGlobalAnnotation(code, keyword)
            [match,tok] = regexp(code, ['^\s*%\s*@' keyword '\s*(\(.*?\))?'], ...
                'match', 'tokens', 'dotexceptnewline', 'lineanchors');
            if isempty(match)
                isPresent = false;
                nPresent = 0;
                options = {};
            else
                isPresent = true;
                nPresent = numel(match);
                tok = tok{1};
                if isempty(tok)
                    options = {};
                else
                    options = regexp(regexprep(tok{1}, '[\(\)]', ''), '\s*,\s*', 'split');
                end
            end
            end
        [isPlanarClass,planarClassOptions] = findGlobalAnnotation(code, 'planarclass');
        if isempty(~isPlanarClass)
            error('No @planarclass annotation found on this class. Not generating boilerplate.');
        end
        out.planarClassOptions = planarClassOptions;
        [~,identityFields,nIdentityAnnotations] = findGlobalAnnotation(code, 'planaridentity');
        if nIdentityAnnotations > 1
            error('Found multiple @planaridentity tags. Only one is allowed.');
        end
        out.planarIdentityFields = identityFields;
        hasPlanarNoSetops = findGlobalAnnotation(code, 'planarnosetops');
        out.doSetops = ~hasPlanarNoSetops;
        % Find property annotations
            function out = findPropertiesWithAnnotation(lines, keyword)
            [~,tok] = regexp(lines, ['^\s*(\S+) .*%.*@' keyword '(?=\s|$)'], ...
                'match', 'tokens', 'dotexceptnewline', 'lineanchors');
            tok = tok(~cellfun(@isempty, tok));
            tok = [tok{:}];
            if isempty(tok)
                out = {};
            else
                out = [tok{:}];
            end
            end
        propertiesSections = regexp(code, '^\s*properties\s.*?^\s*end(?=\s|$)', ...
            'match', 'lineanchors');
        planarNanFields = {};
        planarNoNanFields = {};
        planarNanFlags = {};
        for i = 1:numel(propertiesSections)
            lines = strsplit(propertiesSections{i}, '\n')';
            planarNanFields = [planarNanFields findPropertiesWithAnnotation(lines, 'planar')]; %#ok<*AGROW>
            planarNoNanFields = [planarNoNanFields findPropertiesWithAnnotation(lines, 'planarnonan')];
            planarNanFlags = [planarNanFlags findPropertiesWithAnnotation(lines, 'planarnanflag')];
        end
        planarFields = [ planarNanFields planarNoNanFields ];
        out.planarFields = planarFields;
        out.planarNoNanFields = planarNoNanFields;
        out.planarNanFields = planarNanFields;
        out.planarNanFlags = planarNanFlags;
        if isscalar(out.planarNanFlags)
            out.planarNanFlag = out.planarNanFlag{1};
        end
        out.hasPlanarNanFlag = ~isempty(out.planarNanFlag);
        end
        
        function notes = detectClassProperties(this, fqClassName, userCode, notes) %#ok<INUSL>
        %DETECTCLASSPROPERTIES
        
        % Save the user code to a bogus class definition file so we can use Matlab's
        % meta facility to detect what the user has defined, instead of
        % attempting to parse it ourselves
        
        try
            testClassName = sprintf('PlanarClassGenTestClass%d', round(rand*999999999999));
            myTempDir = tempname;
            mkdir(myTempDir);
            tempFile = fullfile(myTempDir, [testClassName '.m']);
            testCode = regexprep(userCode, 'classdef *\S+', ['classdef ' testClassName]);
            jl.io.spew(tempFile, testCode);
            addpath(myTempDir);
            klass = meta.class.fromName(testClassName);
            notes.isHandle = recursiveSearchForSuperclass(klass, 'handle');
            notes.usesPlanarClassBase = recursiveSearchForSuperclass(klass, ...
                'jl.code.PlanarClassBase');
            if isempty(klass.MethodList)
                notes.userMethodNames = {};
            else
                notes.userMethodNames = setdiff({klass.MethodList.Name}, {testClassName});
            end
            fprintf('Found user methods: %s\n', strjoin(notes.userMethodNames, ', '));
            notes.hasUserIsNan = ismember('isnan', notes.userMethodNames);
            notes.hasUserSubsref = ismember('subsref', notes.userMethodNames);
            notes.hasUserSubsasgn = ismember('subsasgn', notes.userMethodNames);
            notes.hasUserNumArgumentsFromSubscript = ismember('numArgumentsFromSubscript', ...
                notes.userMethodNames);
            rmpath(myTempDir);
            delete(tempFile);
            rmdir(myTempDir);
        catch err
            error(['Could not detect class structure of %s.\n' ...
                'Error: %s\n' ...
                'This probably means a syntax error in the class definition.'], ...
                fqClassName, err.message);
        end
        end
        
        function out = scanCode(this, originalCode)
        %SCANCODE
        out = struct;
        % Detect existing boilerplate section
        [ixStart,ixEnd] = regexp(originalCode, ...
            ['^\s*' this.boilerplateHeader '.*?' this.boilerplateFooter], ...
            'once', 'start', 'end', 'lineanchors');
        extraSpace = '';
        % No existing section? Stick it before the last 'end'
        % BUG: For classes with local functions, this'll put it in the wrong
        % place.
        if isempty(ixStart)
            %fprintf('No existing gen-planar boilerplate section found. Sticking at end.\n');
            [ixEndToken] = regexp(originalCode, '^\s*end\s*(%.*)?$', ...
                'lineanchors', 'dotexceptnewline');
            ixStart = ixEndToken(end) - 1;
            ixEnd = ixStart;
            extraSpace = sprintf('\n\n');
        end
        
        [ixStartPrivate,ixEndPrivate] = regexp(originalCode, ...
            [this.boilerplateLocalFcnHeader '.*?' this.boilerplateLocalFcnFooter], ...
            'once', 'start', 'end');
        localFcnExtraSpace = '';
        if isempty(ixStartPrivate)
            ixStartPrivate = numel(originalCode) + 1;
            ixEndPrivate = ixStartPrivate;
            localFcnExtraSpace = sprintf('\n\n');
        end
        userCode = [originalCode(1:ixStart-1) sprintf('\n') originalCode(ixEnd+1:end)]; %#ok<SPRINTFN>

        out.originalCode = originalCode;
        out.ixBoilerplate = [ixStart ixEnd];
        out.boilerplateExtraSpace = extraSpace;
        out.ixLocalFcnBoilerplate = [ixStartPrivate ixEndPrivate];
        out.localFcnExtraSpace = localFcnExtraSpace;
        out.userCode = userCode;
        end
        
        function validateDefinition(this, defn) %#ok<INUSL>
        %VALIDATEDEFINITION Validate planar definition found in file
        if isempty(defn.planarFields)
            error('No @planar fields were found in class definition. At least one is required.');
        end
        bad = setdiff(defn.planarIdentityFields, defn.planarFields);
        if ~isempty(bad)
            error(['These fields were specified in @planaridentity(...) but are not marked ' ...
                'as @planar. That''s not allowed. Fields: %s'], ...
                strjoin(bad, ', '));
        end
        if defn.isHandle
            warning('jl:code:GenPlanarIncompleteHandleSupport', ...
                'genPlanarClass''s @handle support is incomplete and possibly broken. Use at your own risk.');
        end
        if numel(cellstr(defn.planarNanFlags)) > 1
            error('Found multiple @planarnanflag properties (%s). Only one is allowed.', ...
                strjoin(defn.planarNanFlags, ', '));
        end
        if ~isempty(defn.planarNanFlag) && ~ismember(defn.planarNanFlag, defn.planarFields)
            error('Field ''%s'' is marked @planarnanflag, but not @planar. @planar is required.', ...
                defn.planarNanFlag);
        end
        end
        
        
        function genBoilerplate(this, file)
        %GENPOILERPLATE (re-)generate the boilerplate in a classdef file
        
        %parser = jl.code.internal.PlanarClassParser;
        realFile = which(file);
        if isempty(realFile)
            error('File not found: %s', file);
        end
        fqClassName = this.determineClassName(realFile);
        fprintf('Generating method definitions for class: %s\n', fqClassName);
        defn = this.inspectFile(realFile);
        if defn.usesPlanarClassBase
            b = this.genBoilerplateForBaseClass(fqClassName, defn);
        else
            b = this.genBoilerplateForStandalone(fqClassName, defn);
        end
        newCode = this.assembleBoilerplateIntoNewCode(defn.codeInfo, b);
        bakFile = [realFile '.bak'];
        copyfile(realFile, bakFile);
        try
            jl.io.spew(realFile, newCode);
        catch err
            % Something went wrong. Restore the original file.
            try
                copyfile(bakFile, realfile);
                delete(bakFile);
            catch err2
                fprintf(['Unable to restore original state of file ''%s''.\n' ...
                    'Error: %s\n'
                    'Your original file is at ''%s'''], ...
                    realFile, err2.message, bakFile);
            end
            error('Error while generating ''%s'': %s', realFile, err.message);
        end
        end
        
        function out = assembleBoilerplateIntoNewCode(this, codeInfo, boilerplateParts)
        %ASSEMBLEBOILERPLATEINTONEWCODE
        b = boilerplateParts;
        boilerplate = {
            this.boilerplateHeader
            ''
            this.boilerplateMessage
            ''};
        if ~isempty(b.protectedDefns)
            boilerplate = [boilerplate; {
                'methods (Access=protected)'
                ''};
                this.indent2(strjoin(b.protectedDefns, '\n\n'))                
                {''
                'end'
                ''}];
        end
        if ~isempty(b.publicDefns)
            boilerplate = [boilerplate; {
                'methods'
                ''
                this.indent2(strjoin(b.publicDefns, '\n\n'))
                ''
                'end'
                ''
                }];
        end
        if ~isempty(b.privateDefns)
            boilerplate = [boilerplate; {
                'methods (Access=private)'
                ''
                this.indent2(strjoin(b.privateDefns, '\n\n'))
                ''
                'end'
                ''
                }];
        end
        boilerplate = [boilerplate;
            this.boilerplateFooter
            ];        
        boilerplate = strjoin(boilerplate, '\n');
        if isempty(b.localFcnDefns)
            localFcnBoilerplate = '';
        else
            localFcnBoilerplate = strjoin({
                this.boilerplateLocalFcnHeader
                ''
                this.boilerplateMessage
                ''
                strjoin(b.localFcnDefns, '\n\n')
                ''
                this.boilerplateLocalFcnFooter
                }, '\n');
        end

        % Update the file
        boilerplate = this.indent2(boilerplate);
        originalCode = codeInfo.originalCode;
        newCode = [originalCode(1:codeInfo.ixBoilerplate(1)-1) ...
            codeInfo.boilerplateExtraSpace ...
            boilerplate ...
            codeInfo.boilerplateExtraSpace ...
            originalCode(codeInfo.ixBoilerplate(2)+1:codeInfo.ixLocalFcnBoilerplate(1)-1) ...
            codeInfo.localFcnExtraSpace ...
            localFcnBoilerplate ...
            codeInfo.localFcnExtraSpace ...
            originalCode(codeInfo.ixLocalFcnBoilerplate(2)+1:end)
            ];
        out = newCode;
        end
        
        function out = genBoilerplateForBaseClass(this, fqClassName, notes)
        %GENBOILERPLATEFORBASECLASS The implementation of actual generation
        %
        % This version is for classes that inherit from PlanarClassBase.
        this.validateAnnotations(notes);
        planarFields = notes.planarFields;
        fprintf('Found planar fields: %s\n', strjoin(planarFields, ', '));
        if isempty(notes.planarIdentityFields)
            planarIdentityFields = planarFields;
            fprintf('Treating all planar fields as identity fields.\n');
        else
            planarIdentityFields = notes.planarIdentityFields;
            fprintf('Using specified identity fields: %s\n', strjoin(planarIdentityFields, ', '));
        end
        firstField = planarFields{1};
        
        % TODO: Check old boilerplate for user-defined functions that
        % shouldn't be there and balk if present
        
            function out = subst(str)
            varnames = fieldnames(vars);
            out = str;
            for iVar = 1:numel(varnames)
                if ~isempty(vars.(varnames{iVar}))
                    out = strrep(out, ['<' varnames{iVar} '>'], vars.(varnames{iVar}));
                end
            end
            end
            function out = perfield(str, fields)
            if nargin < 2; fields = planarFields; end
            str = cellstr(str);
            str = str(:);
            out = {};
            for iPlanarField = 1:numel(fields)
                vars.field = fields{iPlanarField};
                out = [out; subst(str)]; %#ok<*AGROW>
            end
            end
        
        % Produce and insert boilerplate
        vars = struct;
        vars.obj = this.objName;
        vars.class = fqClassName;
        vars.nanflag = notes.planarNanFlag;
        vars.firstfield = firstField;

        publicDefns = {};
        protectedDefns = {};
        privateDefns = {};
        localFcnDefns = {};
        
        protectedDefns{end+1} = subst(strjoin([{
            'function [out,fieldNames] = getPlanarFields(<obj>)'
            '%GETPLANARFIELDS Get the values and names of this'' planar fields'
            'out = {'}
            perfield({'    <obj>.<field>'})
            '}'';'
            'if nargout > 1'
            ['    fieldNames = {' strjoin(strcat('''', planarFields, ''''), ' ') '};']
            'end'
            'end'
            ], '\n'));
        protectedDefns{end+1} = subst(strjoin({
            'function out = getFirstPlanarField(<obj>)'
            '%GETFIRSTPLANARFIELD Gets the first planar field'
            'out = <obj>.<firstfield>;'
            'end'
            }, '\n'));
        if ~isequal(planarFields, planarIdentityFields)
            protectedDefns{end+1} = subst(strjoin([{
            'function [out,fieldNames] = getPlanarIdentityFields(<obj>)'
            '%GETPLANARIDENTITYFIELDS Get the values and names of this'' planar identity fields'
            'out = {'}
            perfield({'    <obj>.<field>'}, planarIdentityFields)
            '}'';'
            'if nargout > 1'
            ['    fieldNames = {' strjoin(strcat('''', planarIdentityFields, ''''), ' ') '};']
            'end'
            'end'
            ], '\n'));
        end
        defn = {
            'function <obj> = asgnPlanarFields(<obj>, values)'
            '%ASGNPLANARFIELDS Assign values in to planar fields'};
        for i = 1:numel(planarFields)
            defn{end+1} = ['<obj>.' planarFields{i} ' = values{' num2str(i) '};'];
        end
        defn{end+1} = 'end';
        protectedDefns{end+1} = subst(strjoin(defn, '\n'));
        protectedDefns{end+1} = subst(strjoin({
            'function varargout = promoteArgs(varargin)'
            '%PROMOTEARGS Promote all inputs to the method dispatch class'
            'varargout = varargin;'
            'for i = 1:nargin'
            '    if ~isa(varargin{i}, ''<class>'')'
            '        varargout{i} = <class>(varargin{i});'
            '    end'
            'end'
            'end'
            }, '\n'));
        if ~isempty(notes.planarNanFlag) && ~notes.hasUserIsNan
            publicDefns{end+1} = subst(strjoin({
                'function out = isnan(<obj>)'
                '%ISNAN True for Not-a-Number'
                'out = <obj>.<nanflag>;'
                'end'}));
        end
        
        out = struct;
        out.publicDefns = publicDefns;
        out.protectedDefns = protectedDefns;
        out.privateDefns = privateDefns;
        out.localFcnDefns = localFcnDefns;
        end
        
        function out = genBoilerplateForStandalone(this, fqClassName, notes)
        %GENBOILERPLATESTANDALONE The implementation of actual generation
        %
        % This version is for standalone class definitions.
        
        % Detect planar class properties
        this.validateDefinition(notes);
        planarFields = notes.planarFields;
        fprintf('Found planar fields: %s\n', strjoin(planarFields, ', '));
        if ~isempty(notes.planarIdentityFields)
            fprintf('Generating relops: (%s)\n', strjoin(notes.planarIdentityFields, ' > '));
        end
        if notes.doSetops
            fprintf('Generating setops methods.\n');
        end
        firstField = planarFields{1};
        
        % TODO: Check old boilerplate for user-defined functions that
        % shouldn't be there and balk if present
        
        % Produce and insert boilerplate
        vars = struct;
        vars.obj = this.objName;
        vars.class = fqClassName;
        vars.nanflag = notes.planarNanFlag;

            function out = subst(str)
            varnames = fieldnames(vars);
            out = str;
            for iVar = 1:numel(varnames)
                if ~isempty(vars.(varnames{iVar}))
                    out = strrep(out, ['<' varnames{iVar} '>'], vars.(varnames{iVar}));
                end
            end
            end
        
            function out = perfield(str, fields)
            if nargin < 2; fields = planarFields; end
            str = cellstr(str);
            str = str(:);
            out = {};
            for iPlanarField = 1:numel(fields)
                vars.field = fields{iPlanarField};
                out = [out; subst(str)];
            end
            end
        
        publicDefns = {};
        protectedDefns = {};
        privateDefns = {};
        % Query delegates
        for iFcn = 1:size(this.simpleQueryDelegates, 1)
            [vars.fcn,vars.H1] = this.simpleQueryDelegates{iFcn,:};
            vars.FCN = upper(vars.fcn);
            vars.field = firstField;
            publicDefns{end+1} = subst(strjoin({
                'function out = <fcn>(<obj>)'
                '%<FCN> <H1>'
                'out = <fcn>(<obj>.<field>);'
                'end'
                }, '\n'));
        end
        if ~notes.hasUserIsNan
            nanableFields = setdiff(planarFields, [notes.planarNoNanFields notes.planarNanFlag]);
            defn = {
                'function out = isnan(<obj>)'
                '%ISNAN True for Not-a-Number.'
                };
            if isempty(nanableFields)
                if isempty(notes.planarNanFlag)
                    defn{end+1} = 'out = false(size(<obj>));';
                else
                    defn{end+1} = 'out = <obj>.<nanflag>;';
                end
            else
                checks = cellfun(@(fld) ['isnan2(<obj>.' fld ')'], nanableFields, ...
                    'UniformOutput',false);
                defn{end+1} = ['out = ' strjoin(checks, ' ...\n        | ') ';'];
                if ~isempty(notes.planarNanFlag)
                    defn{end+1} = 'out(<obj>.<nanflag>) = true;';
                end
            end
            defn{end+1} = 'end';
            defn = strjoin(subst(defn), '\n');
            publicDefns{end+1} = defn;
        end
        % Transform delegates
        for iFcn = 1:size(this.transformDelegates, 1)
            [vars.fcn,vars.H1] = this.transformDelegates{iFcn,:};
            vars.FCN = upper(vars.fcn);
            if this.isHandle
                defn = subst([{
                    'function <fcn>(<obj>, varargin)'
                    '%<FCN> <H1>'}
                    perfield('tmp_<field> = <fcn>(<obj>.<field>, varargin{:});')
                    perfield('<obj>.<field> = tmp_<field>;')
                    {'end'}]);
            else
                defn = subst([{
                    'function <obj> = <fcn>(<obj>, varargin)'
                    '%<FCN> <H1>'}
                    perfield('<obj>.<field> = <fcn>(<obj>.<field>, varargin{:});')
                    {'end'}]);
            end
            defn = strjoin(defn, '\n');
            publicDefns{end+1} = defn;
        end
        % Special delegates
        if this.isHandle
            defn = subst([{
                'function [nshifts] = shiftdim(<obj>, n)'
                '%SHIFTDIM Shift dimensions.'
                'if nargin > 1'}
                perfield('    tmp_<field> = shiftdim(<obj>.<field>, n);')
                perfield('    <obj>.<field> = tmp_<field>;')
                {'else'}
                perfield('    [tmp_<field>, nshifts] = shiftdim(<obj>.<field>);')
                perfield('    <obj>.<field> = tmp_<field>;')
                {'end'
                'end'
                }]);
        else
            defn = subst([{
                'function [<obj>, nshifts] = shiftdim(<obj>, n)'
                '%SHIFTDIM Shift dimensions.'
                'if nargin > 1'}
                perfield('    <obj>.<field> = shiftdim(<obj>.<field>, n);')
                {'else'}]);
            for iFld = 1:numel(planarFields)-1
                vars.field = planarFields{iFld};
                defn{end+1} = subst('    <obj>.<field> = shiftdim(<obj>.<field>);');
            end
            vars.field = planarFields{end};
            defn{end+1} = subst('    [<obj>.<field>,nshifts] = shiftdim(<obj>.<field>);');
            defn = [defn; {
                'end'
                'end'}];
        end
        publicDefns{end+1} = strjoin(defn, '\n');
        defn = subst([{
            'function out = cat(dim, varargin)'
            '%CAT Concatenate arrays.'
            'args = varargin;'
            'for i = 1:numel(args)'
            '    if ~isa(args{i}, ''<class>'')'
            '        args{i} = <class>(args{i});'
            '    end'
            'end'
            'out = args{1};'}
            perfield({
            'fieldArgs = cellfun(@(obj) obj.<field>, args, ''UniformOutput'', false);'
            'out.<field> = cat(dim, fieldArgs{:});'
            })
            {'end'}]);
        publicDefns{end+1} = strjoin(defn, '\n');
        publicDefns{end+1} = subst(strjoin({
            'function out = horzcat(varargin)'
            '%HORZCAT Horizontal concatenation.'
            'out = cat(2, varargin{:});'
            'end'
            }, '\n'));
        publicDefns{end+1} = subst(strjoin({
            'function out = vertcat(varargin)'
            '%VERTCAT Vertical concatenation.'
            'out = cat(1, varargin{:});'
            'end'
            }, '\n'));
        if ~notes.hasUserSubsasgn
            publicDefns{end+1} = subst(strjoin({
                'function <obj> = subsasgn(<obj>, s, b)'
                '%SUBSASGN Subscripted assignment.'
                ''
                '% Chained subscripts'
                'if numel(s) > 1'
                '    rhs_in = subsref(<obj>, s(1));'
                '    rhs = subsasgn(rhs_in, s(2:end), b);'
                'else'
                '    rhs = b;'
                'end'
                ''
                '% Base case'
                'switch s(1).type'
                '    case ''()'''
                '        <obj> = subsasgnParensPlanar(<obj>, s(1), rhs);'
                '    case ''{}'''
                '        error(''jl:BadOperation'',...'
                '            ''{}-subscripting is not supported for class %s'', class(<obj>));'
                '    case ''.'''
                '        <obj>.(s(1).subs) = rhs;'
                'end'
                'end'
                }, '\n'));
        end
        if ~notes.hasUserSubsref
            publicDefns{end+1} = subst(strjoin({
                'function out = subsref(<obj>, s)'
                '%SUBSREF Subscripted reference.'
                ''
                '% Base case'
                'switch s(1).type'
                '    case ''()'''
                '        out = subsrefParensPlanar(<obj>, s(1));'
                '    case ''{}'''
                '        error(''jl:BadOperation'',...'
                '            ''{}-subscripting is not supported for class %s'', class(<obj>));'
                '    case ''.'''
                '        out = this.(s(1).subs);'
                'end'
                ''
                '% Chained reference'
                'if numel(s) > 1'
                '    out = subsref(out, s(2:end));'
                'end'
                'end'
                }, '\n'));
        end
        if ~notes.hasUserNumArgumentsFromSubscript
            publicDefns{end+1} = subst(strjoin({
                'function n = numArgumentsFromSubscript(<obj>,~,indexingContext) %#ok<INUSL>'
                'switch indexingContext'
                '    case matlab.mixin.util.IndexingContext.Statement'
                '        n = 1; % nargout for indexed reference used as statement'
                '    case matlab.mixin.util.IndexingContext.Expression'
                '        n = 1; % nargout for indexed reference used as function argument'
                '    case matlab.mixin.util.IndexingContext.Assignment'
                '        n = 1; % nargin for indexed assignment'
                'end'
                'end'
                }, '\n'));
        end
        % Planar relops and setops
        publicDefns = publicDefns(:);
        if ~isempty(notes.planarIdentityFields)
            publicDefns = [publicDefns; this.generatePlanarRelops(vars, notes)];
        end
        if notes.doSetops
            publicDefns = [publicDefns; this.generatePlanarSetops(vars, notes)];
        end
        
        privateDefns{end+1} = subst(strjoin([{
            'function <obj> = subsasgnParensPlanar(<obj>, s, rhs)'
            '%SUBSASGNPARENSPLANAR ()-assignment for planar object'
            'if ~isa(rhs, ''<class>'')'
            '    rhs = <class>(rhs);'
            'end'}
            perfield('<obj>.<field>(s.subs{:}) = rhs.<field>;')
            {'end'}
            ], '\n'));
        privateDefns{end+1} = subst(strjoin([{
            'function out = subsrefParensPlanar(<obj>, s)'
            '%SUBSREFPARENSPLANAR ()-indexing for planar object'
            'out = <obj>;'}
            perfield('out.<field> = <obj>.<field>(s.subs{:});')
            {'end'}
            ], '\n'));
        privateDefns{end+1} = subst(strjoin({
            'function out = parensRef(<obj>, varargin)'
            '%PARENSREF ()-indexing, for this class''s internal use'
            'out = subsrefParensPlanar(<obj>, struct(''subs'', {varargin}));'
            'end'
            }, '\n'));
        privateDefns{end+1} = subst(strjoin({
            'function out = subset(<obj>, varargin)'
            '%SUBSET Subset array by indexes.'
            '% This is what you call internally inside the class instead of doing '
            '% ()-indexing references on the RHS, which don''t work properly inside the class'
            '% because they don''t respect the subsref() override.'
            'out = parensRef(<obj>, varargin{:});'
            'end'
            }, '\n'));
        privateDefns{end+1} = subst(strjoin({
            'function out = asgn(<obj>, ix, value)'
            '%ASGN Assign array elements by indexes.'
            '% This is what you call internally inside the class instead of doing '
            '% ()-indexing references on the LHS, which don''t work properly inside'
            '% the class because they don''t respect the subsasgn() override.'
            'if ~iscell(ix)'
            '    ix = { ix };'
            'end'
            's.type = ''()'';'
            's.subs = ix;'
            'out = subsasgnParensPlanar(<obj>, s, value);'
            'end'
            }, '\n'));
        % Provide a default proxyKeys() implementation if the user has not
        % supplied one
        if ismember('proxyKeys', notes.userMethodNames)
            fprintf('User has supplied a proxyKeys() definition. Using that one.\n');
        else
            defn = subst(strjoin({
                'function [keysA,keysB] = proxyKeys(a, b)'
                '%PROXYKEYS Proxy key values for sorting and set operations'
                ['propertyValsA = {' strjoin(strcat('a.', planarFields), ' ') '};']
                'propertyTypesA = cellfun(@class, propertyValsA, ''UniformOutput'',false);'
                'isAllNumericA = all(cellfun(@isnumeric, propertyValsA));'
                'propertyValsA = cellfun(@(x) x(:), propertyValsA, ''UniformOutput'',false);'
                'if nargin == 1'
                '    if isAllNumericA && isscalar(unique(propertyTypesA))'
                '        % Properties are homogeneous numeric types; we can use them directly '
                '        keysA = cat(2, propertyValsA{:});'
                '    else'
                '        % Properties are heterogeneous or non-numeric; resort to using a table'
                ['        propertyNames = {' strjoin(strcat('''', planarFields, ''''), ' ') '};']
                '        keysA = table(propertyValsA{:}, ''VariableNames'', propertyNames);'
                '    end'
                'else'
                ['    propertyValsB = {' strjoin(strcat('b.', planarFields), ' ') '};']
                '    propertyTypesB = cellfun(@class, propertyValsB, ''UniformOutput'',false);'
                '    isAllNumericB = all(cellfun(@isnumeric, propertyValsB));'
                '    propertyValsB = cellfun(@(x) x(:), propertyValsB, ''UniformOutput'',false);'   
                '    if isAllNumericA && isAllNumericB && isscalar(unique(propertyTypesA)) ...'
                '        && isscalar(unique(propertyTypesB))'
                '        % Properties are homogeneous numeric types; we can use them directly'
                '        keysA = cat(2, propertyValsA{:});'
                '        keysB = cat(2, propertyValsB{:});'
                '    else'
                '        % Properties are heterogeneous or non-numeric; resort to using a table'
                ['        propertyNames = {' strjoin(strcat('''', planarFields, ''''), ' ') '};']
                '        keysA = table(propertyValsA{:}, ''VariableNames'', propertyNames);'
                '        keysB = table(propertyValsB{:}, ''VariableNames'', propertyNames);'
                '    end'
                'end'
                'end'
                }, '\n'));
            publicDefns{end+1} = defn;
        end
        % Local utility functions for the use of other methods
        localFcnDefns = {};
        % scalarexpand() and size2str() are currently unused
        % Matlab does automatic scalar expansion on the "|" and "&" operations,
        % and that's where I thought we'd need this.
        %{
        localFcnDefns{end+1} = subst(strjoin({
            'function [a,b] = scalarexpand(a, b)'
            '%SCALAREXPAND Expand scalar values to match other array size'
            'isScalarA = isscalar(a);'
            'isScalarB = isscalar(b);'
            'if isScalarA && isScalarB'
            '    return;'
            'elseif ~isScalarA && ~isScalarB'
            '    if ~isequal(size(a), size(b))'
            '        error(''jl:DimensionMismatch'', ''Inconsistent sizes: got %s vs %s'', ...'
            '            size2str(size(a)), size2str(size(b)));'
            '    end'
            'elseif isScalarA'
            '    a = repmat(a, size(b));'
            'elseif isScalarB'
            '    b = repmat(b, size(a));'
            'end'
            'end'
            }, '\n'));
        localFcnDefns{end+1} = subst(strjoin({
            'function out = size2str(sz)'
            '%SIZE2STR Convert a size array to displayable string'
            'strs = num2str(sz(:));'
            'strs = regexprep(cellstr(strs), '' +'', '''');'
            'out = strjoin(strs, ''-by-'');'
            'end'
            }, '\n'));
        %}
        localFcnDefns{end+1} = subst(strjoin({
            'function out = isnan2(x)'
            '%ISNAN2 True if input is NaN or NaT'
            '% This is a hack to work around the edge case of @datetime, which '
            '% defines an isnat() function instead of supporting isnan() like '
            '% everything else.'
            'if isa(x, ''datetime'')'
            '    out = isnat(x);'
            'else'
            '    out = isnan(x);'
            'end'
            'end'
            }, '\n'));
        
        out = struct;
        out.publicDefns = publicDefns;
        out.protectedDefns = protectedDefns;
        out.privateDefns = privateDefns;
        out.localFcnDefns = localFcnDefns;
        
        end
        
        function out = generatePlanarRelops(this, vars, notes) %#ok<INUSL>
        planarFields = notes.planarFields;
        relopsFields = notes.planarIdentityFields;
        firstField = planarFields{1};
        vars.field1 = firstField;
            function out = subst(str)
            varnames = fieldnames(vars);
            out = str;
            for iVar = 1:numel(varnames)
                if ~isempty(vars.(varnames{iVar}))
                    out = strrep(out, ['<' varnames{iVar} '>'], vars.(varnames{iVar}));
                end
            end
            end
            function out = perfield(str, fields)
            if nargin < 2; fields = planarFields; end
            str = cellstr(str);
            str = str(:);
            out = {};
            for iPlanarField = 1:numel(fields)
                vars.field = fields{iPlanarField};
                out = [out; subst(str)];
            end
            end
        
        publicDefns = {};
        
        defn = strjoin(subst({
            'function out = size(<obj>, dim)'
            '%SIZE Size of array.'
            'if nargin == 1'
            '    out = size(<obj>.<field1>);'
            'else'
            '    out = size(<obj>.<field1>, dim);'
            'end'
            'end'
            }), '\n');
        publicDefns{end+1} = defn;
        defn = strjoin(subst([{
            'function out = eq(a, b)'
            '%EQ == Equal.'
            'if ~isa(a, ''<class>'')'
            '    a = <class>(a);'
            'end'
            'if ~isa(b, ''<class>'')'
            '    b = <class>(b);'
            'end'
            'tf = a.<field1> == b.<field1>;'}
            perfield('tf(tf) = a.<field>(tf) == b.<field>(tf);', relopsFields(2:end))
            'out = tf;'
            condsection(notes.isNanable, {
            'tfNan = isnan(a) | isnan(b);'
            'out(tfNan) = false;'
            })
            'end']), '\n');
        publicDefns{end+1} = defn;
        ops = {
            'lt'    'LT < Less than.'       '<'
            'gt'    'GT > Greater than.'    '>'
            };
        for iOp = 1:size(ops,1)
            [fcn, h1, op] = ops{iOp,:};
            [vars.fcn, vars.H1, vars.op] = deal(fcn, h1, op);
            defn = subst({
                'function out = <fcn>(a, b)'
                '%<H1>'
                'if ~isa(a, ''<class>'')'
                '    a = <class>(a);'
                'end'
                'if ~isa(b, ''<class>'')'
                '    b = <class>(b);'
                'end'
                'out = false(size(a));'
                'tfUndecided = true(size(out));'
                });
            for i = 1:numel(relopsFields)
                vars.field = relopsFields{i};
                defn = [defn; subst({
                    '% Check field <field>'
                    'lhs = a.<field>(tfUndecided);'
                    'rhs = b.<field>(tfUndecided);'
                    'tfThisStep = lhs <op> rhs;'
                    'out(tfUndecided) = tfThisStep;'
                    })];
                if i < numel(relopsFields)
                    defn = [defn; subst({
                        'tfUndecided(tfUndecided) = ~tfThisStep & ~isnan(lhs) & ~isnan(rhs);'
                        })];
                end
            end
            defn = [defn; subst([
                condsection(notes.isNanable, {
                '% Check NaN flags'
                'tfNan = isnan(a) | isnan(b);'
                'out(tfNan) = false;'
                })
                'end'])];
            defn = strjoin(defn, '\n');
            publicDefns{end+1} = defn;
        end
        publicDefns{end+1} = subst(strjoin({
            'function out = ne(a, b)'
            '%NE ~= Not equal.'
            'out = ~(a == b);'
            'end'
            }, '\n'));
        % These LE/GE implementations are suboptimal, but easy to get correct.
        publicDefns{end+1} = subst(strjoin({
            'function out = le(a, b)'
            '%LE <= Less than or equal.'
            'out = a < b | a == b;'
            'end'
            }, '\n'));
        publicDefns{end+1} = subst(strjoin({
            'function out = ge(a, b)'
            '%GE <= Greater than or equal.'
            'out = a > b | a == b;'
            'end'
            }, '\n'));
        defn = subst(strjoin({
            'function out = cmp(a, b)'
            '%CMP Compare values for ordering.'
            '%'
            '% CMP compares values elementwise, returning for each element:'
            '%   -1 if a(i) < b(i)'
            '%   0  if a(i) == b(i)'
            '%   1  if a(i) > b(i)'
            '%   NaN if either a(i) or b(i) were NaN, or no relop methods returned'
            '%       true'
            '%'
            '% Returns an array the same size as a and b (after scalar expansion).'
            ''
            'if ~isa(a, ''<class>'')'
            '    a = <class>(a);'
            'end'
            'if ~isa(b, ''<class>'')'
            '    b = <class>(b);'
            'end'
            'out = NaN(size(a));'
            'tfUndecided = true(size(out));'
            '% Test <'
            'tf = a < b;'
            'out(tf) = -1;'
            'tfUndecided(tf) = false;'
            '% Test =='
            'tf = a(tfUndecided) == b(tfUndecided);'
            'nextTest = NaN(size(tf));'
            'nextTest(tf) = 0;';
            'out(tfUndecided) = nextTest;'
            'tfUndecided(tfUndecided) = ~tf;'
            '% Test >'
            'tf = a(tfUndecided) > b(tfUndecided);'
            'nextTest = NaN(size(tf));'
            'nextTest(tf) = 1;';
            'out(tfUndecided) = nextTest;'
            'tfUndecided(tfUndecided) = ~tf; %#ok<NASGU>'
            '% Anything left over is either NaN inputs or an unsupported relop'
            '% Leave it as NaN.'
            'end'
            }, '\n'));
        publicDefns{end+1} = defn;
        out = publicDefns(:);
        end
        
        function out = generatePlanarSetops(this, vars, notes) %#ok<INUSL,INUSD>
            function subst_out = subst(str)
            varnames = fieldnames(vars);
            subst_out = str;
            for iVar = 1:numel(varnames)
                if ~isempty(vars.(varnames{iVar}))
                    subst_out = strrep(subst_out, ['<' varnames{iVar} '>'], vars.(varnames{iVar}));
                end
            end
            end
        publicDefns = {};
        publicDefns{end+1} = subst(strjoin({
            'function [out,Indx] = sort(<obj>)'
            '%SORT Sort array elements.'
            'if isvector(<obj>)'
            '    isRow = isrow(<obj>);'
            '    <obj> = subset(<obj>, '':'');'
            '    % NaNs sort stably to end, so handle them separately'
            '    tfNan = isnan(<obj>);'
            '    nans = subset(<obj>, tfNan);'
            '    nonnans = subset(<obj>, ~tfNan);'
            '    ixNonNan = find(~tfNan);'
            '    proxy = proxyKeys(nonnans);'
            '    [~,ix] = sortrows(proxy);'
            '    out = [subset(nonnans, ix); nans];'
            '    Indx = [ixNonNan(ix); find(tfNan)];'
            '    if isRow'
            '        out = out'';'
            '    end'
            'elseif ismatrix(<obj>)'
            '    out = <obj>;'
            '    Indx = NaN(size(out));'
            '    for iCol = 1:size(<obj>, 2)'
            '        [sortedCol,Indx(:,iCol)] = sort(subset(<obj>, '':'', iCol));'
            '        out = asgn(out, {'':'', iCol}, sortedCol);'
            '    end'
            'else'
            '    % I believe this multi-dimensional implementation is correct,'
            '    % but have not tested it yet. Use with caution.'
            '    out = <obj>;'
            '    Indx = NaN(size(out));'
            '    sz = size(<obj>);'
            '    nDims = ndims(<obj>);'
            '    ixs = [{'':''} repmat({1}, [1 nDims-1])];'
            '    while true'
            '        col = subset(<obj>, ixs{:});'
            '        [sortedCol,sortIx] = sort(col);'
            '        Indx(ixs{:}) = sortIx;'
            '        out = asgn(out, ixs, sortedCol);'
            '        ixs{end} = ixs{end}+1;'
            '        for iDim=nDims:-1:3'
            '            if ixs{iDim} > sz(iDim)'            
            '                ixs{iDim-1} = ixs{iDim-1} + 1;'
            '                ixs{iDim} = 1;'
            '            end'
            '        end'
            '        if ixs{2} > sz(2)'
            '            break;'
            '        end'
            '    end'
            'end'
            'end'
            }, '\n'));
        publicDefns{end+1} = subst(strjoin({
            'function [out,Indx] = unique(<obj>, varargin)'
            '%UNIQUE Set unique.'
            'flags = setdiff(varargin, {''rows''});'
            'if ismember(''rows'', varargin)'
            '    [~,proxyIx] = unique(<obj>);'
            '    proxyIx = reshape(proxyIx, size(<obj>));'
            '    [~,Indx] = unique(proxyIx, ''rows'', flags{:});'
            '    out = subset(<obj>, Indx, '':'');'
            'else'
            '    isRow = isrow(<obj>);'
            '    <obj> = subset(<obj>, '':'');'
            '    tfNaN = isnan(<obj>);'
            '    nans = subset(<obj>, tfNaN);'
            '    nonnans = subset(<obj>, ~tfNaN);'
            '    ixNonnan = find(~tfNaN);'
            '    keys = proxyKeys(nonnans);'
            '    if isa(keys, ''table'')'
            '        [~,ix] = unique(keys, flags{:});'
            '    else'
            '        [~,ix] = unique(keys, ''rows'', flags{:});'
            '    end'
            '    out = [subset(nonnans, ix); nans];'
            '    Indx = [ixNonnan(ix); find(tfNaN)];'
            '    if isRow'
            '        out = out'';'
            '    end'
            'end'
            'end'
            }, '\n'));
        publicDefns{end+1} = subst(strjoin({
            'function [out,Indx] = ismember(a, b, varargin)'
            '%ISMEMBER True for set member.'
            'if ismember(''rows'', varargin)'
            '    error(''ismember(..., ''''rows'''') is unsupported'');'
            'end'
            'if ~isa(a, ''<class>'')'
            '    a = <class>(a);'
            'end'
            'if ~isa(b, ''<class>'')'
            '    b = <class>(b);'
            'end'
            '[proxyA, proxyB] = proxyKeys(a, b);'
            '[out,Indx] = ismember(proxyA, proxyB, ''rows'');'
            'out = reshape(out, size(a));'
            'Indx = reshape(Indx, size(a));'
            'end'
            }, '\n'));
        publicDefns{end+1} = subst(strjoin({
            'function [out,Indx] = setdiff(a, b, varargin)'
            '%SETDIFF Set difference.'
            'if ismember(''rows'', varargin)'
            '    error(''setdiff(..., ''''rows'''') is unsupported'');'
            'end'
            '[tf,~] = ismember(a, b);'
            'out = parensRef(a, ~tf);'
            'Indx = find(~tf);'
            '[out,ix] = unique(out);'
            'Indx = Indx(ix);'
            'end'
            }, '\n'));
        publicDefns{end+1} = subst(strjoin({
            'function [out,ia,ib] = intersect(a, b, varargin)'
            '%INTERSECT Set intersection.'
            'if ismember(''rows'', varargin)'
            '    error(''intersect(..., ''''rows'''') is unsupported'');'
            'end'
            '[proxyA, proxyB] = proxyKeys(a, b);'
            '[~,ia,ib] = intersect(proxyA, proxyB, ''rows'');'
            'out = parensRef(a, ia);'
            'end'
            }, '\n'));
        publicDefns{end+1} = subst(strjoin({
            'function [out,ia,ib] = union(a, b, varargin)'
            '%UNION Set union.'
            'if ismember(''rows'', varargin)'
            '    error(''union(..., ''''rows'''') is unsupported'');'
            'end'
            '[proxyA, proxyB] = proxyKeys(a, b);'
            '[~,ia,ib] = union(proxyA, proxyB, ''rows'');'
            'aOut = parensRef(a, ia);'
            'bOut = parensRef(b, ib);'
            'out = [parensRef(aOut, '':''); parensRef(bOut, '':'')];'
            'end'
            }, '\n'));
        out = publicDefns(:);
        end
        
        function out = indent2(this, strs) %#ok<INUSL>
        out = regexprep(strs, '^(?=.)', '    ', 'lineanchors', 'emptymatch');
        end
    end
end

function out = recursiveSearchForSuperclass(klass, targetClass)
out = false;
if isequal(klass.Name, targetClass)
    out = true;
    return;
end
for i = 1:numel(klass.SuperclassList)
    out = recursiveSearchForSuperclass(klass.SuperclassList(i), targetClass);
    if out
        return;
    end
end
end

function out = condsection(condition, section)
%CONDSECTION Conditional section, only included if condition is true
if condition
    out = section;
else
    out = {};
end
end
