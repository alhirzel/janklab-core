classdef OneFieldPlanar
    
    % @planarprecedence(foo)
    % @planarsetops
    
    properties
        foo % @planar
    end
    
    

    %%%%% START PLANAR-CLASS BOILERPLATE CODE %%%%%
    
    % This section contains code auto-generated by Janklab's genPlanarClass.
    % Do not edit code in this section manually.
    % Do not remove the "%%%%% START/END .... %%%%%" header or footer either;
    % that will cause the code regeneration to break.
    % To update this code, re-run jl.code.genPlanarClass() on this file.
    
    methods
    
        function out = size(this)
        %SIZE Size of array.
        out = size(this.foo);
        end
        
        function out = numel(this)
        %NUMEL Number of elements in array.
        out = numel(this.foo);
        end
        
        function out = ndims(this)
        %NDIMS Number of dimensions.
        out = ndims(this.foo);
        end
        
        function out = isempty(this)
        %ISEMPTY True for empty array.
        out = isempty(this.foo);
        end
        
        function out = isscalar(this)
        %ISSCALAR True if input is scalar.
        out = isscalar(this.foo);
        end
        
        function out = isvector(this)
        %ISVECTOR True if input is a vector.
        out = isvector(this.foo);
        end
        
        function out = iscolumn(this)
        %ISCOLUMN True if input is a column vector.
        out = iscolumn(this.foo);
        end
        
        function out = isrow(this)
        %ISROW True if input is a row vector.
        out = isrow(this.foo);
        end
        
        function out = ismatrix(this)
        %ISMATRIX True if input is a matrix.
        out = ismatrix(this.foo);
        end
        
        function out = isnan(this)
        %ISNAN True for Not-a-Number.
        out = isnan2(this.foo);
        end
        
        function this = reshape(this, varargin)
        %RESHAPE Reshape array.
        this.foo = reshape(this.foo, varargin{:});
        end
        
        function this = squeeze(this, varargin)
        %SQUEEZE Remove singleton dimensions.
        this.foo = squeeze(this.foo, varargin{:});
        end
        
        function this = circshift(this, varargin)
        %CIRCSHIFT Shift positions of elements circularly.
        this.foo = circshift(this.foo, varargin{:});
        end
        
        function this = permute(this, varargin)
        %PERMUTE Permute array dimensions.
        this.foo = permute(this.foo, varargin{:});
        end
        
        function this = ipermute(this, varargin)
        %IPERMUTE Inverse permute array dimensions.
        this.foo = ipermute(this.foo, varargin{:});
        end
        
        function this = repmat(this, varargin)
        %REPMAT Replicate and tile array.
        this.foo = repmat(this.foo, varargin{:});
        end
        
        function this = ctranspose(this, varargin)
        %CTRANSPOSE Complex conjugate transpose.
        this.foo = ctranspose(this.foo, varargin{:});
        end
        
        function this = transpose(this, varargin)
        %TRANSPOSE Transpose vector or matrix.
        this.foo = transpose(this.foo, varargin{:});
        end
        
        function [this, nshifts] = shiftdim(this, n)
        %SHIFTDIM Shift dimensions.
        if nargin > 1
            this.foo = shiftdim(this.foo, n);
        else
            [this.foo,nshifts] = shiftdim(this.foo);
        end
        end
        
        function out = cat(dim, varargin)
        %CAT Concatenate arrays.
        args = varargin;
        for i = 1:numel(args)
            if ~isa(args{i}, 'jl.test.code.OneFieldPlanar')
                args{i} = jl.test.code.OneFieldPlanar(args{i});
            end
        end
        out = args{1};
        fieldArgs = cellfun(@(obj) obj.foo, args, 'UniformOutput', false);
        out.foo = cat(dim, fieldArgs{:});
        end
        
        function out = horzcat(varargin)
        %HORZCAT Horizontal concatenation.
        out = cat(2, varargin{:});
        end
        
        function out = vertcat(varargin)
        %VERTCAT Vertical concatenation.
        out = cat(1, varargin{:});
        end
        
        function this = subsasgn(this, s, b)
        %SUBSASGN Subscripted assignment.
        
        % Chained subscripts
        if numel(s) > 1
            rhs_in = subsref(this, s(1));
            rhs = subsasgn(rhs_in, s(2:end), b);
        else
            rhs = b;
        end
        
        % Base case
        switch s(1).type
            case '()'
                this = subsasgnParensPlanar(this, s(1), rhs);
            case '{}'
                error('jl:BadOperation',...
                    '{}-subscripting is not supported for class %s', class(this));
            case '.'
                this.(s(1).subs) = rhs;
        end
        end
        
        function out = subsref(this, s)
        %SUBSREF Subscripted reference.
        
        % Base case
        switch s(1).type
            case '()'
                out = subsrefParensPlanar(this, s(1));
            case '{}'
                error('jl:BadOperation',...
                    '{}-subscripting is not supported for class %s', class(this));
            case '.'
                out = this.(s(1).subs);
        end
        
        % Chained reference
        if numel(s) > 1
            out = subsref(out, s(2:end));
        end
        end
        
        function n = numArgumentsFromSubscript(this,~,indexingContext) %#ok<INUSL>
        switch indexingContext
            case matlab.mixin.util.IndexingContext.Statement
                n = 1; % nargout for indexed reference used as statement
            case matlab.mixin.util.IndexingContext.Expression
                n = 1; % nargout for indexed reference used as function argument
            case matlab.mixin.util.IndexingContext.Assignment
                n = 1; % nargin for indexed assignment
        end
        end
        
        function out = eq(a, b)
        %EQ == Equal.
        if ~isa(a, 'jl.test.code.OneFieldPlanar')
            a = jl.test.code.OneFieldPlanar(a);
        end
        if ~isa(b, 'jl.test.code.OneFieldPlanar')
            b = jl.test.code.OneFieldPlanar(b);
        end
        tf = a.foo == b.foo;
        out = tf;
        end
        
        function out = lt(a, b)
        %LT < Less than.
        if ~isa(a, 'jl.test.code.OneFieldPlanar')
            a = jl.test.code.OneFieldPlanar(a);
        end
        if ~isa(b, 'jl.test.code.OneFieldPlanar')
            b = jl.test.code.OneFieldPlanar(b);
        end
        out = false(size(a));
        tfUndecided = true(size(out));
        % Check field foo
        lhs = a.foo(tfUndecided);
        rhs = b.foo(tfUndecided);
        tfThisStep = lhs < rhs;
        out(tfUndecided) = tfThisStep;
        end
        
        function out = gt(a, b)
        %GT > Greater than.
        if ~isa(a, 'jl.test.code.OneFieldPlanar')
            a = jl.test.code.OneFieldPlanar(a);
        end
        if ~isa(b, 'jl.test.code.OneFieldPlanar')
            b = jl.test.code.OneFieldPlanar(b);
        end
        out = false(size(a));
        tfUndecided = true(size(out));
        % Check field foo
        lhs = a.foo(tfUndecided);
        rhs = b.foo(tfUndecided);
        tfThisStep = lhs > rhs;
        out(tfUndecided) = tfThisStep;
        end
        
        function out = ne(a, b)
        %NE ~= Not equal.
        out = ~(a == b);
        end
        
        function out = le(a, b)
        %LE <= Less than or equal.
        out = a < b | a == b;
        end
        
        function out = ge(a, b)
        %GE <= Greater than or equal.
        out = a > b | a == b;
        end
        
        function out = cmp(a, b)
        %CMP Compare values for ordering.
        %
        % CMP compares values elementwise, returning for each element:
        %   -1 if a(i) < b(i)
        %   0  if a(i) == b(i)
        %   1  if a(i) > b(i)
        %   NaN if either a(i) or b(i) were NaN, or no relop methods returned
        %       true
        %
        % Returns an array the same size as a and b (after scalar expansion).
        
        if ~isa(a, 'jl.test.code.OneFieldPlanar')
            a = jl.test.code.OneFieldPlanar(a);
        end
        if ~isa(b, 'jl.test.code.OneFieldPlanar')
            b = jl.test.code.OneFieldPlanar(b);
        end
        out = NaN(size(a));
        tfUndecided = true(size(out));
        % Test <
        tf = a < b;
        out(tf) = -1;
        tfUndecided(tf) = false;
        % Test ==
        tf = a(tfUndecided) == b(tfUndecided);
        nextTest = NaN(size(tf));
        nextTest(tf) = 0;
        out(tfUndecided) = nextTest;
        tfUndecided(tfUndecided) = ~tf;
        % Test >
        tf = a(tfUndecided) > b(tfUndecided);
        nextTest = NaN(size(tf));
        nextTest(tf) = 1;
        out(tfUndecided) = nextTest;
        tfUndecided(tfUndecided) = ~tf; %#ok<NASGU>
        % Anything left over is either NaN inputs or an unsupported relop
        end
        
        function [out,Indx] = sort(this)
        %SORT Sort array elements.
        if isvector(this)
            isRow = isrow(this);
            this = subset(this, ':');
            % NaNs sort stably to end, so handle them separately
            tfNan = isnan(this);
            nans = subset(this, tfNan);
            nonnans = subset(this, ~tfNan);
            ixNonNan = find(~tfNan);
            proxy = proxyKeys(nonnans);
            [~,ix] = sortrows(proxy);
            out = [subset(nonnans, ix); nans];
            Indx = [ixNonNan(ix); find(tfNan)];
            if isRow
                out = out';
            end
        elseif ismatrix(this)
            out = this;
            Indx = NaN(size(out));
            for iCol = 1:size(this, 2)
                [sortedCol,Indx(:,iCol)] = sort(subset(this, ':', iCol));
                out = asgn(out, {':', iCol}, sortedCol);
            end
        else
            % I believe this multi-dimensional implementation is correct,
            % but have not tested it yet. Use with caution.
            out = this;
            Indx = NaN(size(out));
            sz = size(this);
            nDims = ndims(this);
            ixs = [{':'} repmat({1}, [1 nDims-1])];
            while true
                col = subset(this, ixs{:});
                [sortedCol,sortIx] = sort(col);
                Indx(ixs{:}) = sortIx;
                out = asgn(out, ixs, sortedCol);
                ixs{end} = ixs{end}+1;
                for iDim=nDims:-1:3
                    if ixs{iDim} > sz(iDim)
                        ixs{iDim-1} = ixs{iDim-1} + 1;
                        ixs{iDim} = 1;
                    end
                end
                if ixs{2} > sz(2)
                    break;
                end
            end
        end
        end
        
        function [out,Indx] = unique(this)
        UNIQUE Set unique.
        [~,Indx] = ismember(this, this);
        Indx = unique(Indx);
        out = parensRef(this, Indx);
        [out,ix] = sort(out);
        Indx = Indx(ix);
        end
        
        function [out,Indx] = ismember(a, b)
        %ISMEMBER True for set member.
        if ~isa(a, 'jl.test.code.OneFieldPlanar')
            a = jl.test.code.OneFieldPlanar(a);
        end
        if ~isa(b, 'jl.test.code.OneFieldPlanar')
            b = jl.test.code.OneFieldPlanar(b);
        end
        [proxyA, proxyB] = proxyKeys(a, b);
        [out,Indx] = ismember(proxyA, proxyB, 'rows');
        out = reshape(out, size(a));
        Indx = reshape(Indx, size(a));
        end
        
        function [out,Indx] = setdiff(a, b)
        %SETDIFF Set difference.
        [tf,~] = ismember(a, b);
        out = parensRef(a, ~tf);
        Indx = find(~tf);
        [out,ix] = unique(out);
        Indx = Indx(ix);
        end
        
        function [out,ia,ib] = intersect(a, b, varargin)
        %INTERSECT Set intersection.
        if ismember('rows', varargin)
            error('intersect(..., ''rows'') is unsupported');
        end
        [proxyA, proxyB] = proxyKeys(a, b);
        [~,ia,ib] = intersect(proxyA, proxyB, 'rows');
        out = parensRef(a, ia);
        end
        
        function [out,ia,ib] = union(a, b)
        %UNION Set union.
        [proxyA, proxyB] = proxyKeys(a, b);
        [~,ia,ib] = union(proxyA, proxyB, 'rows');
        aOut = parensRef(a, ia);
        bOut = parensRef(b, ib);
        out = [parensRef(aOut, ':'); parensRef(bOut, ':')];
        end
        
        function [keysA,keysB] = proxyKeys(a, b)
        %PROXYKEYS Proxy key values for sorting and set operations
        propertyValsA = {a.foo};
        propertyTypesA = cellfun(@class, propertyValsA, 'UniformOutput',false);
        isAllNumericA = all(cellfun(@isnumeric, propertyValsA));
        propertyValsA = cellfun(@(x) x(:), propertyValsA, 'UniformOutput',false);
        if nargin == 1
            if isAllNumericA && isscalar(unique(propertyTypesA))
                % Properties are homogeneous numeric types; we can use them directly 
                keysA = cat(2, propertyValsA{:});
            else
                % Properties are heterogeneous or non-numeric; resort to using a table
                propertyNames = {'foo'};
                keysA = table(propertyValsA{:}, 'VariableNames', propertyNames);
            end
        else
            propertyValsB = {b.foo};
            propertyTypesB = cellfun(@class, propertyValsB, 'UniformOutput',false);
            isAllNumericB = all(cellfun(@isnumeric, propertyValsB));
            propertyValsB = cellfun(@(x) x(:), propertyValsB, 'UniformOutput',false);
            if isAllNumericA && isAllNumericB && isscalar(unique(propertyTypesA)) ...
                && isscalar(unique(propertyTypesB))
                % Properties are homogeneous numeric types; we can use them directly
                keysA = cat(2, propertyValsA{:});
                keysB = cat(2, propertyValsB{:});
            else
                % Properties are heterogeneous or non-numeric; resort to using a table
                propertyNames = {'foo'};
                keysA = table(propertyValsA{:}, 'VariableNames', propertyNames);
                keysB = table(propertyValsB{:}, 'VariableNames', propertyNames);
            end
        end
        end
    
    end
    
    methods (Access=private)
    
        function this = subsasgnParensPlanar(this, s, rhs)
        %SUBSASGNPARENSPLANAR ()-assignment for planar object
        if ~isa(rhs, 'jl.test.code.OneFieldPlanar')
            rhs = jl.test.code.OneFieldPlanar(rhs);
        end
        this.foo(s.subs{:}) = rhs.foo;
        end
        
        function out = subsrefParensPlanar(this, s)
        %SUBSREFPARENSPLANAR ()-indexing for planar object
        out = this;
        out.foo = this.foo(s.subs{:});
        end
        
        function out = parensRef(this, varargin)
        %PARENSREF ()-indexing, for this class's internal use
        out = subsrefParensPlanar(this, struct('subs', {varargin}));
        end
        
        function out = subset(this, varargin)
        %SUBSET Subset array by indexes.
        % This is what you call internally inside the class instead of doing 
        % ()-indexing references on the RHS, which don't work properly inside the class
        % because they don't respect the subsref() override.
        out = parensRef(this, varargin{:});
        end
        
        function out = asgn(this, ix, value)
        %ASGN Assign array elements by indexes.
        % This is what you call internally inside the class instead of doing 
        % ()-indexing references on the LHS, which don't work properly inside
        % the class because they don't respect the subsasgn() override.
        if ~iscell(ix)
            ix = { ix };
        end
        s.type = '()';
        s.subs = ix;
        out = subsasgnParensPlanar(this, s, value);
        end
    
    end
    
    %%%%% END PLANAR-CLASS BOILERPLATE CODE %%%%%

    end

%%%%% START PLANAR-CLASS BOILERPLATE LOCAL FUNCTIONS %%%%%

% This section contains code auto-generated by Janklab's genPlanarClass.
% Do not edit code in this section manually.
% Do not remove the "%%%%% START/END .... %%%%%" header or footer either;
% that will cause the code regeneration to break.
% To update this code, re-run jl.code.genPlanarClass() on this file.

function out = isnan2(x)
%ISNAN2 True if input is NaN or NaT
% This is a hack to work around the edge case of @datetime, which 
% defines an isnat() function instead of supporting isnan() like 
% everything else.
if isa(x, 'datetime')
    out = isnat(x);
else
    out = isnan(x);
end
end

%%%%% END PLANAR-CLASS BOILERPLATE LOCAL FUNCTIONS %%%%%

